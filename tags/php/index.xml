<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Php on Alexander Makarov</title>
    <link>https://samdark.github.io/tags/php/index.xml</link>
    <description>Recent content in Php on Alexander Makarov</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <atom:link href="https://samdark.github.io/tags/php/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Moving constants into dictionaries</title>
      <link>https://samdark.github.io/blog/moving-constants-into-dictionaries/</link>
      <pubDate>Fri, 02 Jun 2017 03:03:04 +0300</pubDate>
      
      <guid>https://samdark.github.io/blog/moving-constants-into-dictionaries/</guid>
      <description>&lt;p&gt;Extracting constants makes code much cleaner compared to using values directly. It eliminates typos and makes it possible
to use IDE autocomplete and refactoring.&lt;/p&gt;

&lt;p&gt;Typically, after extraction is done, it looks like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;namespace app\models;

class User
{
    const GENDER_FEMALE = &#39;female&#39;;
    const GENDER_MALE = &#39;male&#39;;
    
    public static function listGenders()
    {
        return [
            self::GENDER_FEMALE =&amp;gt; Yii::t(&#39;app&#39;, &#39;Female&#39;),
            self::GENDER_MALE =&amp;gt; Yii::t(&#39;app&#39;, &#39;Male&#39;),
        ];
    }
    
    public static function getGenderAsString($gender)
    {
        $all = self::listGenders();

        if (isset($all[$gender])) {
            return $all[$gender];
        }

        return Yii::t(&#39;app&#39;, &#39;Not set&#39;);
    }
    
    // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or another example from Stay.com project:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;namespace app\models;

class Guide
{
    const THEME_SHOPPING = 2;
    const THEME_ART_AND_CULTURE = 3;
    const THEME_AFTER_DARK = 4;
    const THEME_FAMILY = 5;
    const THEME_COFFEE = 8;
    const THEME_ON_A_BUDGET = 9;
    const THEME_FOOD = 10;
    const THEME_SPORTS_AND_OUTDOORS = 11;
    const THEME_24_HOURS = 12;
    
    public static function listThemes()
    {
        return [
            self::THEME_SHOPPING =&amp;gt; Yii::t(&#39;app&#39;, &#39;Shopping&#39;),
            // ...
        ];
    }
    
    public static function getThemeAsString($theme)
    {
        $all = self::listThemes();

        if (isset($all[$theme])) {
            return $all[$theme];
        }

        return Yii::t(&#39;app&#39;, &#39;Not set&#39;);
    }
    
    // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is more or less OK but some issues are still there:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;It bloats the class.&lt;/li&gt;
&lt;li&gt;Constants could not be reused in different context.&lt;/li&gt;
&lt;li&gt;It creates unnecessary dependency when used with different classes such as form models.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In both examples above it&amp;rsquo;s possible to extract constants into its own class. User case:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;namespace app\dictionaries;

abstract class Gender
{
    const FEMALE = 0;
    const MALE = 1;

    public static function all()
    {
        return [
            self::MALE =&amp;gt; Yii::t(&#39;app&#39;, &#39;Male&#39;),
            self::FEMALE =&amp;gt; Yii::t(&#39;app&#39;, &#39;Female&#39;),
        ];
    }
    
    public static function get($gender)
    {
        $all = self::all();

        if (isset($all[$gender])) {
            return $all[$gender];
        }

        return Yii::t(&#39;app&#39;, &#39;Not set&#39;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Stay.com case:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;namespace app\dictionaries;

abstract class GuideTheme
{
    const SHOPPING = 2;
    const ART_AND_CULTURE = 3;
    const AFTER_DARK = 4;
    const FAMILY = 5;
    const COFFEE = 8;
    const ON_A_BUDGET = 9;
    const FOOD = 10;
    const SPORTS_AND_OUTDOORS = 11;
    const 24_HOURS = 12;
    
    public static function all()
    {
        return [
            self::SHOPPING =&amp;gt; Yii::t(&#39;app&#39;, &#39;Shopping&#39;),
            // ...
        ];
    }
    
    public static function get($theme)
    {
        $all = self::all();

        if (isset($all[$theme])) {
            return $all[$theme];
        }

        return Yii::t(&#39;app&#39;, &#39;Not set&#39;);
    }    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In both cases, additionally to solving issues listed above, it looks either equally good or better than originally:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$user-&amp;gt;gender = Gender::MALE;
// instead of
$user-&amp;gt;gender = User::GENDER_MALE;


$guide-&amp;gt;theme = GuideTheme::COFFEE;
// instead of
$guide-&amp;gt;theme = Guide::THEME_COFFEE;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Hydrator</title>
      <link>https://samdark.github.io/blog/hydrator/</link>
      <pubDate>Sat, 13 May 2017 00:59:27 +0300</pubDate>
      
      <guid>https://samdark.github.io/blog/hydrator/</guid>
      <description>

&lt;p&gt;November 2016 I&amp;rsquo;ve implemented and released a &lt;a href=&#34;https://github.com/samdark/hydrator&#34;&gt;Hydrator library&lt;/a&gt; but never properly
announced it. As far as I know, the &amp;ldquo;hydrator&amp;rdquo; term was first used in &lt;a href=&#34;http://hibernate.org/orm/&#34;&gt;Hibernate Java ORM&lt;/a&gt;.
The job of a hydrator is to fill an object with data or extract data from an object without calling constructor or extra
getter-setter methods. It allows you to directly work with private properties which should be persisted to database
or loaded from database while not exposing these properties thus keeping public interface clean.&lt;/p&gt;

&lt;p&gt;Internally it uses &lt;a href=&#34;http://php.net/manual/en/book.reflection.php&#34;&gt;PHP reflection&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://samdark.github.io/img/posts/hydration.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;usage&#34;&gt;Usage&lt;/h2&gt;

&lt;p&gt;Consider we have a &lt;code&gt;Post&lt;/code&gt; entity which represents a blog post. It has a title and a text. A unique id is generated to
identify it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;class Post
{
    private $id;
    protected $title;
    protected $text;

    public function __construct($title, $text)
    {
        $this-&amp;gt;id = uniqid(&#39;post_&#39;, true);
        $this-&amp;gt;title = $title;
        $this-&amp;gt;text = $text;
    }
   
    public function getId()
    {
        return $this-&amp;gt;id;
    }
    
    public function getTitle()
    {
        return $this-&amp;gt;title;
    }
    
    public function setTitle($title)
    {
        $this-&amp;gt;title = $title;
    }
    
    public function getText()
    {
        return $this-&amp;gt;text;
    }
    
    public function setText()
    {
        return $this-&amp;gt;text;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Saving a post to database:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$post = new Post(&#39;First post&#39;, &#39;Hell, it is a first post.&#39;);

$postHydrator = new \samdark\hydrator\Hydrator([
    &#39;id&#39; =&amp;gt; &#39;id&#39;,
    &#39;title&#39; =&amp;gt; &#39;title&#39;,
    &#39;text&#39; =&amp;gt; &#39;text&#39;,
]);

$data = $postHydrator-&amp;gt;extract($post);
save_to_database($data);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Loading post from database:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
$data = load_from_database();

$postHydrator = new \samdark\hydrator\Hydrator([
    &#39;id&#39; =&amp;gt; &#39;id&#39;,
    &#39;title&#39; =&amp;gt; &#39;title&#39;,
    &#39;text&#39; =&amp;gt; &#39;text&#39;,
]);

$post = $postHydrator-&amp;gt;hydrate($data, Post::class);
echo $post-&amp;gt;getId();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Filling existing post object with data:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;$data = load_from_database();

$postHydrator = new \samdark\hydrator\Hydrator([
    &#39;title&#39; =&amp;gt; &#39;title&#39;,
    &#39;text&#39; =&amp;gt; &#39;text&#39;,
]);

$post = get_post();
$post = $postHydrator-&amp;gt;hydrateInto($data, $post);
echo $post-&amp;gt;getTitle();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;usage-in-yii&#34;&gt;Usage in Yii&lt;/h2&gt;

&lt;p&gt;It&amp;rsquo;s not currently used in Yii in any way. One may use it to implement his own data mapping
in a repository in case of purchasing
&lt;a href=&#34;https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html&#34;&gt;clean architecture&lt;/a&gt;
and &lt;a href=&#34;https://en.wikipedia.org/wiki/Domain-driven_design&#34;&gt;domain driven design&lt;/a&gt; where encapsulation is uber-important.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Are traits evil?</title>
      <link>https://samdark.github.io/blog/are-traits-evil/</link>
      <pubDate>Mon, 17 Apr 2017 13:49:29 +0300</pubDate>
      
      <guid>https://samdark.github.io/blog/are-traits-evil/</guid>
      <description>

&lt;p&gt;When I have started &lt;a href=&#34;https://www.patreon.com/samdark&#34;&gt;a Patreon campaign&lt;/a&gt;, I have promised to answer questions.
First question came from Daniel Fly and is about &lt;a href=&#34;http://php.net/manual/en/language.oop5.traits.php&#34;&gt;PHP traits&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What do you think about Traits in PHP? Do you think they are evil and should avoid using them? If using them what
  are some common pitfalls fx where not to use them? Maybe you got some bad or good experience?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;what-are-traits&#34;&gt;What are traits?&lt;/h2&gt;

&lt;p&gt;PHP manual defines traits as the following:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Traits are a mechanism for code reuse in single inheritance languages such as PHP. A Trait is intended to reduce some
limitations of single inheritance by enabling a developer to reuse sets of methods freely in several independent
classes living in different class hierarchies. The semantics of the combination of Traits and classes is defined
in a way which reduces complexity, and avoids the typical problems associated with multiple inheritance and Mixins.&lt;/p&gt;

&lt;p&gt;A Trait is similar to a class, but only intended to group functionality in a fine-grained and consistent way. It is
not possible to instantiate a Trait on its own. It is an addition to traditional inheritance and enables horizontal
composition of behavior; that is, the application of class members without requiring inheritance.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;That is a way lengthy description. In simple words, if we are not touching inheritance aspect, traits are an enhanced way
to copy-paste.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
trait Dumper
{
    public function dump($var)
    {
        echo &#39;&amp;lt;pre&amp;gt;&#39; . print_r($var, true) . &#39;&amp;lt;/pre&amp;gt;&#39;;
    }
}
 
class MyClass
{
    use Dumper;
}
 
$myClass = new MyClass();
$myClass-&amp;gt;dump(&#39;test&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code above would work similar to:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
class MyClass
{
    public function dump($var)
    {
        echo &#39;&amp;lt;pre&amp;gt;&#39; . print_r($var, true) . &#39;&amp;lt;/pre&amp;gt;&#39;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;traits-and-yii&#34;&gt;Traits and Yii&lt;/h2&gt;

&lt;p&gt;Yii uses traits for low level functionality and common database layer code. Traits were considered to be used for
behaviors in 2.0 and will be considered again for 2.1.&lt;/p&gt;

&lt;h3 id=&#34;behaviors&#34;&gt;Behaviors&lt;/h3&gt;

&lt;p&gt;I have started looking at traits in &lt;a href=&#34;http://rmcreative.ru/blog/post/traits-v-trunk-php&#34;&gt;August 2010&lt;/a&gt; when they were merged
into PHP &lt;code&gt;trunk&lt;/code&gt; (that is how &lt;code&gt;master&lt;/code&gt; was called in CVS/SVN). By that time Yii 1.x had behaviors concept which is similar
to Ruby mixins and is handy for seamlessly adding extra abilities such as &lt;code&gt;SoftDeleteable&lt;/code&gt; or &lt;code&gt;Versionable&lt;/code&gt; to
a class. The main difference is that behavior has its own state and could be attached/detached in runtime while trait
has no own state at all.&lt;/p&gt;

&lt;p&gt;Traits were released before Yii 2.0 so when designing it we considered using them instead of 1.1 behaviors and decided
not to. At that time there were no good ideas on how to make trait powered behavior configurable and
attachable/detachable at runtime.&lt;/p&gt;

&lt;p&gt;For 2.1 the idea popped up again. We have found ways to solve configurability by using abstract methods.
Attaching/detaching proved to be unsolvable but enabling/disabling via subscribing and unsubscribing to/from events is
possible. Final decision is still to be made&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;low-level-functionality&#34;&gt;Low level functionality&lt;/h3&gt;

&lt;p&gt;Yii uses traits for common low level functionality:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/yiisoft/yii2/blob/master/framework/base/ArrayableTrait.php&#34;&gt;ArrayableTrait&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/yiisoft/yii2/blob/master/framework/base/ArrayAccessTrait.php&#34;&gt;ArrayAccessTrait&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That is the most straightforward and correct use for traits.&lt;/p&gt;

&lt;h3 id=&#34;database-layer-common-code&#34;&gt;Database layer common code&lt;/h3&gt;

&lt;p&gt;A bit less straightforward is use of traits in Yii&amp;rsquo;s database layer:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/yiisoft/yii2/blob/master/framework/db/ActiveQueryTrait.php&#34;&gt;ActiveQueryTrait&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/yiisoft/yii2/blob/master/framework/db/ActiveRelationTrait.php&#34;&gt;ActiveRelationTrait&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/yiisoft/yii2/blob/master/framework/db/QueryTrait.php&#34;&gt;QueryTrait&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/yiisoft/yii2/blob/master/framework/db/SchemaBuilderTrait.php&#34;&gt;SchemaBuilderTrait&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/yiisoft/yii2/blob/master/framework/db/ViewFinderTrait.php&#34;&gt;ViewFinderTrait&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Database layer in Yii 2.0 has the same interface for both relational databases and noSQLs.
Common parts in interface implementations are extracted into traits to keep inheritance tree
smaller and to be able not to override too many methods for noSQLs which are different from traditional databases.&lt;/p&gt;

&lt;p&gt;Personally I am not happy with this implementation looking from pure object-oriented perspective.
It could have been done using composition and normal classes to be more testable and easier to read. Still, traits usage
is justifiable because it saves tons of method calls thus making database layer significantly faster. Additionally,
we dealt with testing it despite it not being straightforward.&lt;/p&gt;

&lt;h2 id=&#34;common-pitfalls&#34;&gt;Common pitfalls&lt;/h2&gt;

&lt;p&gt;When you think about using a trait, think twice.&lt;/p&gt;

&lt;h3 id=&#34;no-encapsulation&#34;&gt;No encapsulation&lt;/h3&gt;

&lt;p&gt;When using traits, you should understand the copy-paste aspect of it. Everything inside the trait is magically copied
to the class as is. Of course, you can deal with naming conflicts when using a trait but that does not change the fact
much. Because of that, it is wise to keep amount of code a trait contains to the minimum.&lt;/p&gt;

&lt;p&gt;Ideal usage of traits is about small and simple pieces of code.&lt;/p&gt;

&lt;h3 id=&#34;state&#34;&gt;State&lt;/h3&gt;

&lt;p&gt;Since traits lack proper encapsulation, in order to deal with state you either should add private properties to
the trait or declare &lt;code&gt;static&lt;/code&gt; variables inside a method. Both could lead to issues.&lt;/p&gt;

&lt;p&gt;Private properties are copied to the class using a trait. Possible issues are naming conflicts and accidental
modification of the property. Because in runtime properties are copied into class, class has access to private ones.&lt;/p&gt;

&lt;p&gt;Using &lt;code&gt;static&lt;/code&gt; means all your objects using a trait would share the same state which is not always desired.&lt;/p&gt;

&lt;h2 id=&#34;are-traits-evil&#34;&gt;Are traits evil?&lt;/h2&gt;

&lt;p&gt;Short answer: depending on how you use traits.&lt;/p&gt;

&lt;p&gt;Same as copy-paste they are evil to some degree but there is nothing absolutely evil or absolutely good.&lt;/p&gt;

&lt;p&gt;Traits are useful for reusable interface implementations without the need for a base class. In other cases it is
better to stick with objects composition.&lt;/p&gt;

&lt;h2 id=&#34;further-reading&#34;&gt;Further reading&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.sitepoint.com/using-traits-in-php-5-4/&#34;&gt;Using Traits in PHP 5.4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.sitepoint.com/php-traits-good-or-bad/&#34;&gt;PHP Traits: Good or Bad?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://rosstuck.com/how-i-use-traits/&#34;&gt;How I Use Traits&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.reddit.com/r/PHP/comments/65uyv3/are_traits_evil/&#34;&gt;Comments for this very post at reddit&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>bcrypt hash</title>
      <link>https://samdark.github.io/blog/bcrypt-hash/</link>
      <pubDate>Thu, 23 Mar 2017 11:41:26 +0300</pubDate>
      
      <guid>https://samdark.github.io/blog/bcrypt-hash/</guid>
      <description>&lt;p&gt;bcrypt is a good way to deal with password authentication. In PHP it is available via
&lt;a href=&#34;https://secure.php.net/manual/en/function.crypt.php&#34;&gt;crypt&lt;/a&gt; with blowfish algorithm or a shortcut
&lt;a href=&#34;https://secure.php.net/manual/en/function.password-hash.php&#34;&gt;password_hash&lt;/a&gt; function current PHP versions are providing.&lt;/p&gt;

&lt;p&gt;Yii framework project templates are using bcrypt for handling passwords. Framework components
are &lt;a href=&#34;http://www.yiiframework.com/doc-2.0/yii-base-security.html#generatePasswordHash()-detail&#34;&gt;providing polyfills ensuring bcrypt is used correctly&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;bcrypt produces a compound hash that looks like the following:&lt;/p&gt;

&lt;p&gt;$&lt;strong style=&#34;color: #f00&#34;&gt;2y&lt;/strong&gt;$&lt;strong style=&#34;color: #0a0&#34;&gt;13&lt;/strong&gt;$&lt;strong style=&#34;color: #00f&#34;&gt;YUUgrko03UmNU/fe6gNcO.&lt;/strong&gt;&lt;strong style=&#34;color: #00a&#34;&gt;Hka4lrdRlkq0iJ5d4bv4fK.sKS.6jXu&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The string is always 60 characters long.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong style=&#34;color: #f00&#34;&gt;2y&lt;/strong&gt; indicates algorithm. We are using blowfish so in current PHP versions it should
always be &lt;code&gt;2y&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong style=&#34;color: #0a0&#34;&gt;13&lt;/strong&gt; is computation cost. 2^13 iterations of &lt;a href=&#34;https://en.wikipedia.org/wiki/Key_derivation_function&#34;&gt;key derivation function&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Rest of the string is concatenated salt, and hash encoded with base64 with a custom set of characters.
First 22 symbols are &lt;strong style=&#34;color: #00f&#34;&gt;16 bytes salt&lt;/strong&gt;. The rest are &lt;strong style=&#34;color: #00a&#34;&gt;the hash itself&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When verifying a password input bcrypt extract algorithm version, cost, salt and hash from compound hash string of
a saved password. Then, using the data extracted, it calculates a hash of the input and compares it with the hash
we store.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>